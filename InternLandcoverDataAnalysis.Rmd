---
title: "Intern Landcover Data Analysis"
author: "Emma Jones"
date: "1/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown- Background

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```


## Project Organization

So we are going to use this file (script) as a one stop shop for data analysis for your science fair project. As stated above, you can 'knit' this script into a document to have a record of all the manipulation and analysis steps you took, or you can give this (and the data) to someone else to let them see exactly what you did code-wise with verbose descriptions neatly organized. This style of programming is called literate programming and it helps keep to the nature of open source programming when you share your thoughts as well as actions (code) associated with a project. 

### Libraries

We need to bring in a few packages (aka libraries) in order to step up base R functionality to allow for some neat analyses and visualizations. 

```{r bring in packages}
# Run in R 3.6.2
library(tidyverse) # Version 1.2.1
library(readxl) # Version 1.3.1
```

### Bring in Landcover Metrics

We are going to take the MS Excel spreadsheet with all the landcover metrics and bring each sheet into our environment (into R basically) so we can subset just the metrics we want as well as analyze the datasets for differences.

In the MS Excel spreadsheet, there are three sheets. The first sheet is a data dictionary, the second sheet is the human-delineated landcover data, and the third sheet is the auto-delineated landcover data. We are going to bring the last two sheets into R as separate 'objects' so we can work with them. 

```{r bring in data}
# This is a relative path name based off where your project is located
# You may need to change where R is looking for this file if your directory
#   structure is different than mine
humanShed <- read_excel('Results/Interns2019/FirstOrderResults2001_2016.xlsx',
                    sheet = 'Human Results')
autoShed <- read_excel('Results/Interns2019/FirstOrderResults2001_2016.xlsx',
                    sheet = 'Automated Results')
```

You can now look at each of these object by either clicking on them in the top left panel or by running the code below. They will open on a new tab.

```{r view data}
View(humanShed)
View(autoShed)
```


You can dig into your dataset and understand the structure by using the glimpse() function from the tidyr package (loaded automatically when you loaded tidyverse).

```{r glimpse data}
glimpse(humanShed)
glimpse(autoShed)
```

We also need bioregion information associated with these sites so we can make further analyses comparing metrics across regions of our state. We will get that data by joining our sites to an existing dataset with that information.

```{r join Bioregion}
# Bring in ProbMon Data
probData <- read_csv('data/Wadeable_ProbMon_2001-2016_EVJ.csv') %>%
  select(StationID, Year, BioRegion) %>% # select only the columns we want
  rename('YearSampled' = 'Year') # rename Year column so it will join

# Join based on info in 'left' dataset ( we dont care about all the sites in probData)
humanShed <- left_join(humanShed, probData, by = c('StationID','YearSampled'))
autoShed <- left_join(autoShed, probData, by = c('StationID','YearSampled'))
```

Awesome. Can you figure out how to look at this new information? Hint: glimpse



### Subset Datasets to Parameters of Interest

We have already run the ordination and picked the metrics that are the least correlated for you to test (done by a previous intern). To make the dataset a bit more manageable, we will drop the parameters that are not needed for this analysis. We will use the select() function from the dplyr package (loaded when we brought in tidyverse).

```{r select metrics}
# there are a few parameters, so let's make an object to save their names and make subsetting the data much cleaner
metricsOfInterest <- c('totalArea_sqMile', 'PFOR', 'PWETL', 'RFOR30',
                       'MunMinor', 'siteRain_mmyr', 'ELEVMEAN')

humanShed <- select(humanShed, StationID, YearSampled, BioRegion, metricsOfInterest) %>%
  mutate_at(metricsOfInterest, as.numeric) # make sure these all are numeric values
autoShed <- select(autoShed, StationID, YearSampled, BioRegion, metricsOfInterest) %>% 
  mutate_at(metricsOfInterest, as.numeric) # make sure these all are numeric values
```


Analysis time.

## Area Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r watershed area histogram}
# First the human results
ggplot(data = humanShed, aes(x = totalArea_sqMile)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = totalArea_sqMile)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r area t test}
t.test(humanShed$totalArea_sqMile, autoShed$totalArea_sqMile)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
library(CDFt)
```


```{r area cvm}
CVM_Area <- CramerVonMisesTwoSamples(humanShed$totalArea_sqMile,autoShed$totalArea_sqMile)
CVM_Area # print result

# Convert U result from cvm to a p value
CVM_P_Area<- 1/6*exp(-CVM_Area)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_Area <- tibble(ID = 'Watershed Area', 
                     cvm = CVM_Area,
                     pValue = CVM_P_Area)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion area boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = totalArea_sqMile, fill = type)) +
  geom_boxplot()
  
```



To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
humanShed_Mountain <- filter(humanShed, BioRegion == 'Mountain')
humanShed_Piedmont <- filter(humanShed, BioRegion == 'Piedmont')
humanShed_Coast <- filter(humanShed, BioRegion == 'Coast')

autoShed_Mountain <- filter(autoShed, BioRegion == 'Mountain')
autoShed_Piedmont <- filter(autoShed, BioRegion == 'Piedmont')
autoShed_Coast <- filter(autoShed, BioRegion == 'Coast')
```

Now we will run cvm on each subpopulation. 

```{r area cvm by bioregion}

CVM_Area_M <- tibble(ID = 'Watershed Area Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$totalArea_sqMile,
                                       autoShed_Mountain$totalArea_sqMile))
CVM_Area_P <- tibble(ID = 'Watershed Area Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$totalArea_sqMile,
                                       autoShed_Piedmont$totalArea_sqMile))
CVM_Area_C <- tibble(ID = 'Watershed Area Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$totalArea_sqMile,
                                       autoShed_Coast$totalArea_sqMile))

# Combine to single tibble
CVM_Area <- rbind(CVM_Area_M, CVM_Area_P, CVM_Area_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_Area) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_Area_C); rm(CVM_Area_M);rm(CVM_P_Area); rm(CVM_Area_P)
```


## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.

```{r reminder of parameters}
metricsOfInterest
```


## Save Results

When you are finished, you can combine your results into a single object and save your results to a csv file like so:

```{r save results}
# Combine results
allResults <- rbind(CVM_Area, CVM_PFOR, CVM_PWETL, CVM_RFOR30, 
                    CVM_MunMinor, CVM_siteRain_mmyr, CVM_ELEVMEAN)
# save results
write.csv(allResults, 'CVM_results.csv', row.names = FALSE)

```




## Maps

Now we are going to update the maps for your poster with R instead of using Esri's ArcGIS software (proprietary). These maps will be exported to a .png for easy inclusion in your poster-building software. We are going to use the sf package in R to use spatial data objects for plotting and then use the ggplot2 package (loaded with tidyverse package) for the actual plots.

```{r bring in spatial library}
library(sf)
```

First, we need spatial data in order to make maps. But notice in the glimpse() above that there is no actual spatial information for us to plot in the results (no latitude/longitude information or shapes for the polygons). We will need to bring in the raw spatial data you all processed in order to make maps. 

```{r bring in spatial data}
wshdPolys <- st_read('GISdata/InternSpatialData/final/TwinWatersheds_prj.shp') %>% # watersheds
  st_transform(4326) #reproject to WGS84 for mapping
wshdSites <- st_read('GISdata/InternSpatialData/final/TwinSites_prj.shp') %>% # points
    st_transform(4326) #reproject to WGS84 for mapping
```

And we will bring in a few base layers to make the maps a bit more understandable: a Virginia state outline and US EPA Level III Ecoregions. 

```{r bring in baselayers}
VAoutline <- st_read('GISdata/InternSpatialData/mapData/Va_otlne.shp')
VAecoregions <- st_read('GISdata/InternSpatialData/mapData/VA_level3ecoregion.shp')
```

The ecoregions brought in don't quite match the way we analyzed our dataset above (Mountain, Piedmont, Coast). Have a look at what came in:

```{r ecoregion options}
unique(VAecoregions$US_L3NAME)
```

We will need to simplify this layer to match our previous analysis. We will do that by combining the ecoregions by this format: 
Combined level III EcoRegions - 69, 67, 66 = Mountain 
                                 64,45 = Piedmont 
                                 65,63 = coastal plain
                                 
Here is all the code to do so, don't worry about understanding it all.

```{r combine ecoregions to bioregions for plotting}
VAbioregions <- mutate(VAecoregions, 
                       Bioregion = as.factor(case_when(US_L3CODE %in% c(66, 67, 69) ~ 'Mountain',
                                             US_L3CODE %in% c(45, 64) ~ 'Piedmont',
                                             US_L3CODE %in% c(63, 65) ~ 'Coast'))) %>%
  group_by(Bioregion) %>% # group by new variable
  summarise() # make into unified geometries
```


Last check, before we can plot things on the same map, we need to make sure their coordinate reference system (CRS) and projections are the same. These refer to how the data are represented on a 2D space and basically makes sure things will look like we expect them to look. 

```{r crs check}
# test if everyone has same crs, first the long way
st_crs(wshdPolys) == st_crs(wshdSites)
st_crs(wshdPolys) == st_crs(VAbioregions)
st_crs(wshdPolys) == st_crs(VAoutline)
st_crs(wshdSites) == st_crs(VAbioregions)
st_crs(wshdSites) == st_crs(VAoutline)
st_crs(VAbioregions) == st_crs(VAoutline)
# a bit complicated to make sure you are really testing every possible combination

# test if everyone has same crs, now the short way, this is called a function
all(sapply(list(st_crs(wshdPolys), st_crs(wshdSites), st_crs(VAbioregions), st_crs(VAoutline)),
           function(x) x == st_crs(wshdPolys)))
```


First let's plot where our polygons fall out across the state (we want to demonstrate how they are not clustered in on area within state).

```{r VA map and polgons}
ggplot(data = VAoutline) +
  geom_sf() +
  geom_sf(data = wshdPolys)
```

Now a map to demonstrate the spread of sites across bioregions.

```{r Bioregion map and points}
ggplot(data = VAbioregions) +
  geom_sf() +
  geom_sf(data = wshdSites)
```


And now let's make these into publishable maps (make them pretty). 

```{r pretty watershed map}
library(ggthemes)

watershedPlot <- ggplot(data = VAoutline) +
  geom_sf() +
  geom_sf(data = wshdPolys, fill="white") + 
  ggthemes::theme_map()
watershedPlot
```


```{r}
bioregionPlot <- ggplot(data = VAbioregions) +
  geom_sf(aes(fill = Bioregion)) +
  geom_sf(data = wshdSites) + 
  theme_void()
bioregionPlot
```


```{r}
ggsave("watershedPlot.png", plot = watershedPlot, width = 6, height = 6, dpi = "screen")
ggsave("bioregionPlot.png", plot = bioregionPlot, width = 6, height = 6, dpi = "screen")

```

