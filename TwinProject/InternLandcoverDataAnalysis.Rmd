---
title: "Intern Landcover Data Analysis"
author: "Emma Jones"
date: "1/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Run in R 3.6.2
library(tidyverse) # Version 1.2.1
library(readxl) # Version 1.3.1
library(CDFt)
library(sf)
library(ggthemes)
```


```{r}
.libPaths()
```

## R Markdown- Background

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```


## Project Organization

So we are going to use this file (script) as a one stop shop for data analysis for your science fair project. As stated above, you can 'knit' this script into a document to have a record of all the manipulation and analysis steps you took, or you can give this (and the data) to someone else to let them see exactly what you did code-wise with verbose descriptions neatly organized. This style of programming is called literate programming and it helps keep to the nature of open source programming when you share your thoughts as well as actions (code) associated with a project. 

### Libraries

We need to bring in a few packages (aka libraries) in order to step up base R functionality to allow for some neat analyses and visualizations. 

```{r bring in packages}
# Run in R 3.6.2
library(tidyverse) # Version 1.2.1
library(readxl) # Version 1.3.1
```

### Bring in Landcover Metrics

We are going to take the MS Excel spreadsheet with all the landcover metrics and bring each sheet into our environment (into R basically) so we can subset just the metrics we want as well as analyze the datasets for differences.
s
In the MS Excel spreadsheet, there are three sheets. The first sheet is a data dictionary, the second sheet is the human-delineated landcover data, and the third sheet is the auto-delineated landcover data. We are going to bring the last two sheets into R as separate 'objects' so we can work with them. 

```{r bring in data}
# This is a relative path name based off where your project is located
# You may need to change where R is looking for this file if your directory
#   structure is different than mine
humanShed <- read_excel('data/Results/FirstOrderResults2001_2016.xlsx',
                    sheet = 'Human Results')
autoShed <- read_excel('data/Results/FirstOrderResults2001_2016.xlsx',
                    sheet = 'Automated Results')
```

You can now look at each of these object by either clicking on them in the top left panel or by running the code below. They will open on a new tab.

```{r view data}
View(humanShed)
View(autoShed)
```


You can dig into your dataset and understand the structure by using the glimpse() function from the tidyr package (loaded automatically when you loaded tidyverse).

```{r glimpse data}
glimpse(humanShed)
glimpse(autoShed)
```

We also need bioregion information associated with these sites so we can make further analyses comparing metrics across regions of our state. We will get that data by joining our sites to an existing dataset with that information.

```{r join Bioregion}
# Bring in ProbMon Data
probData <- read_csv('data/Wadeable_ProbMon_2001-2016_EVJ.csv') %>%
  select(StationID, Year, BioRegion) %>% # select only the columns we want
  rename('YearSampled' = 'Year') # rename Year column so it will join

# Join based on info in 'left' dataset ( we dont care about all the sites in probData)
humanShed <- left_join(humanShed, probData, by = c('StationID','YearSampled'))
autoShed <- left_join(autoShed, probData, by = c('StationID','YearSampled'))
```

Awesome. Can you figure out how to look at this new information? Hint: glimpse

```{r}
glimpse(autoShed)
```


### Subset Datasets to Parameters of Interest

We have already run the ordination and picked the metrics that are the least correlated for you to test (done by a previous intern). To make the dataset a bit more manageable, we will drop the parameters that are not needed for this analysis. We will use the select() function from the dplyr package (loaded when we brought in tidyverse).

```{r select metrics}
# there are a few parameters, so let's make an object to save their names and make subsetting the data much cleaner
metricsOfInterest <- c('totalArea_sqMile', 'PFOR', 'PWETL', 'RFOR30',
                       'MunMinor', 'siteRain_mmyr', 'ELEVMEAN')

humanShed <- select(humanShed, StationID, YearSampled, BioRegion, metricsOfInterest) %>%
  mutate_at(metricsOfInterest, as.numeric) # make sure these all are numeric values
autoShed <- select(autoShed, StationID, YearSampled, BioRegion, metricsOfInterest) %>% 
  mutate_at(metricsOfInterest, as.numeric) # make sure these all are numeric values
```


Analysis time.

## Area Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r watershed area histogram}
# First the human results
ggplot(data = humanShed, aes(x = totalArea_sqMile)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = totalArea_sqMile)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r area t test}
t.test(humanShed$totalArea_sqMile, autoShed$totalArea_sqMile)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
library(CDFt)
```


```{r area cvm}
CVM_Area <- CramerVonMisesTwoSamples(humanShed$totalArea_sqMile,autoShed$totalArea_sqMile)
CVM_Area # print result

# Convert U result from cvm to a p value
CVM_P_Area<- 1/6*exp(-CVM_Area)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_Area <- tibble(ID = 'Watershed Area', 
                     cvm = CVM_Area,
                     pValue = CVM_P_Area)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion area boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = totalArea_sqMile, fill = type)) +
  geom_boxplot()
  
```

And let's also make a scatterplot to show differences

```{r bioregion area scatterplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
scatterplotArea <- select(humanShed, StationID, BioRegion, totalArea_sqMile) %>%
  rename('totalArea_sqMile_Human' = 'totalArea_sqMile') %>%
  left_join(select(autoShed, StationID, BioRegion, totalArea_sqMile), 
            by = c('StationID','BioRegion')) %>%
  rename('totalArea_sqMile_Auto' = 'totalArea_sqMile') 
scatterplotArea$BioRegion <- as.factor(scatterplotArea$BioRegion)

ggplot(data= scatterplotArea, aes(x = totalArea_sqMile_Human, y = totalArea_sqMile_Auto,
                                  color = BioRegion)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color="black", 
                 linetype="dashed", size=1.5) +
  annotate(geom="text", x=15, y=16, label="1:1",
              color="black")

```


And here is the data plotted with the calculated linear regression line and r^2. I used a function I found online to make this super easy. https://sejohnston.com/2012/08/09/a-quick-and-easy-function-to-plot-lm-results-in-r/

```{r scatterplot with equation function}
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red", se = F) +
  labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 5),
                     "Intercept =",signif(fit$coef[[1]],5 ),
                     " Slope =",signif(fit$coef[[2]], 5),
                     " P =",signif(summary(fit)$coef[2,4], 5)))
}
```


```{r}
ggplotRegression(lm(totalArea_sqMile_Human ~ totalArea_sqMile_Auto, data = scatterplotArea))
```

To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))
# turn BioRegion and type variables into factors such that anova works
allData$BioRegion <- as.factor(allData$BioRegion)
allData$type <- as.factor(allData$type)


# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')

```


First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r totalArea_sqMile anova by bioregion}
summary(
  aov(data = allData, 
      totalArea_sqMile ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run a nonparametric test (cvm) on each subpopulation. 

```{r area cvm by bioregion}

CVM_Area_M <- tibble(ID = 'Watershed Area Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$totalArea_sqMile,
                                       autoShed_Mountain$totalArea_sqMile))
CVM_Area_P <- tibble(ID = 'Watershed Area Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$totalArea_sqMile,
                                       autoShed_Piedmont$totalArea_sqMile))
CVM_Area_C <- tibble(ID = 'Watershed Area Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$totalArea_sqMile,
                                       autoShed_Coast$totalArea_sqMile))

# Combine to single tibble
CVM_Area <- rbind(CVM_Area_M, CVM_Area_P, CVM_Area_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_Area) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_Area_C); rm(CVM_Area_M);rm(CVM_P_Area); rm(CVM_Area_P); rm(scatterplotArea)
```


## PFOR Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r watershed area histogram}
# First the human results
ggplot(data = humanShed, aes(x = PFOR)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = PFOR)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r area t test}
t.test(humanShed$PFOR, autoShed$PFOR)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
#library(CDFt)
```


```{r PFOR cvm}
CVM_PFOR <- CramerVonMisesTwoSamples(humanShed$PFOR,autoShed$PFOR)
CVM_PFOR # print result

# Convert U result from cvm to a p value
CVM_P_PFOR<- 1/6*exp(-CVM_PFOR)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_PFOR <- tibble(ID = 'Watershed Percent Forest', 
                     cvm = CVM_PFOR,
                     pValue = CVM_P_PFOR)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion area boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = PFOR, fill = type)) +
  geom_boxplot()
  
```


And let's also make a scatterplot to show differences

```{r bioregion area scatterplot}

scatterplotArea <- select(humanShed, StationID, BioRegion, PFOR) %>%
  rename('PFOR_Human' = 'PFOR') %>%
  left_join(select(autoShed, StationID, BioRegion, PFOR), 
            by = c('StationID','BioRegion')) %>%
  rename('PFOR_Auto' = 'PFOR') 
scatterplotArea$BioRegion <- as.factor(scatterplotArea$BioRegion)

ggplot(data= scatterplotArea, aes(x = PFOR_Human, y = PFOR_Auto,
                                  color = BioRegion)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color="black", 
                 linetype="dashed", size=1.5) +
  annotate(geom="text", x=15, y=16, label="1:1",
              color="black")
```

```{r}
ggplotRegression(lm(PFOR_Human ~ PFOR_Auto, data = scatterplotArea))

```

To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))

# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')
```

First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r PFOR anova by bioregion}
summary(
  aov(data = allData, 
      PFOR ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run cvm on each subpopulation. 

```{r PFOR cvm by bioregion}

CVM_PFOR_M <- tibble(ID = 'Watershed Percent Forest Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$PFOR,
                                       autoShed_Mountain$PFOR))
CVM_PFOR_P <- tibble(ID = 'Watershed Percent Forest Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$PFOR,
                                       autoShed_Piedmont$PFOR))
CVM_PFOR_C <- tibble(ID = 'Watershed Percent Forest Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$PFOR,
                                       autoShed_Coast$PFOR))

# Combine to single tibble
CVM_PFOR <- rbind(CVM_PFOR_M, CVM_PFOR_P, CVM_PFOR_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_PFOR) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_PFOR_C); rm(CVM_PFOR_M);rm(CVM_P_PFOR); rm(CVM_PFOR_P)
```

## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.

```{r reminder of parameters}
metricsOfInterest
```

## PWETL Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r watershed wetland histogram}
# First the human results
ggplot(data = humanShed, aes(x = PWETL)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = PWETL)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r wetland t test}
t.test(humanShed$PWETL, autoShed$PWETL)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
library(CDFt)
```


```{r area cvm}
CVM_PWETL <- CramerVonMisesTwoSamples(humanShed$PWETL,autoShed$PWETL)
CVM_PWETL # print result

# Convert U result from cvm to a p value
CVM_P_PWETL<- 1/6*exp(-CVM_PWETL)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_PWETL <- tibble(ID = 'Watershed Percent Wetland', 
                     cvm = CVM_PWETL,
                     pValue = CVM_P_PWETL)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion wetland boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = PWETL, fill = type)) +
  geom_boxplot()
  
```

And let's also make a scatterplot to show differences

```{r bioregion wetland scatterplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = PWETL, color = type)) +
  geom_point()
```



To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))
# turn BioRegion and type variables into factors such that anova works
allData$BioRegion <- as.factor(allData$BioRegion)
allData$type <- as.factor(allData$type)


# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')

```


First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r PWETL anova by bioregion}
summary(
  aov(data = allData, 
      PWETL ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run a nonparametric test (cvm) on each subpopulation. 

```{r PWETL cvm by bioregion}

CVM_PWETL_M <- tibble(ID = 'Watershed Percent Wetland Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$PWETL,
                                       autoShed_Mountain$PWETL))
CVM_PWETL_P <- tibble(ID = 'Watershed Percent Wetland Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$PWETL,
                                       autoShed_Piedmont$PWETL))
CVM_PWETL_C <- tibble(ID = 'Watershed Percent Wetland Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$PWETL,
                                       autoShed_Coast$PWETL))

# Combine to single tibble
CVM_PWETL <- rbind(CVM_PWETL_M, CVM_PWETL_P, CVM_PWETL_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_PWETL) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_PWETL_C); rm(CVM_PWETL_M);rm(CVM_P_PWETL); rm(CVM_PWETL_P)
```
## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.

## RFOR30 Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r watershed area histogram}
# First the human results
ggplot(data = humanShed, aes(x = RFOR30)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = RFOR30)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r RFOR30 t test}
t.test(humanShed$RFOR30, autoShed$RFOR30)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
#library(CDFt)
```


```{r RFOR30 cvm}
CVM_RFOR30 <- CramerVonMisesTwoSamples(humanShed$RFOR30,autoShed$RFOR30)
CVM_RFOR30 # print result

# Convert U result from cvm to a p value
CVM_P_RFOR30<- 1/6*exp(-CVM_RFOR30)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_RFOR30 <- tibble(ID = 'Watershed Percent Forest', 
                     cvm = CVM_RFOR30,
                     pValue = CVM_P_RFOR30)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion RFOR30 boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = RFOR30, fill = type)) +
  geom_boxplot()
  
```


And let's also make a scatterplot to show differences

```{r bioregion RFOR30 scatterplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = RFOR30, color = type)) +
  geom_point()
```

To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))

# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')
```

First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r RFOR30 anova by bioregion}
summary(
  aov(data = allData, 
      RFOR30 ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run cvm on each subpopulation. 

```{r RFOR30 cvm by bioregion}

CVM_RFOR30_M <- tibble(ID = 'Watershed Percent Forest Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$RFOR30,
                                       autoShed_Mountain$RFOR30))
CVM_RFOR30_P <- tibble(ID = 'Watershed Percent Forest Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$RFOR30,
                                       autoShed_Piedmont$RFOR30))
CVM_RFOR30_C <- tibble(ID = 'Watershed Percent Forest Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$RFOR30,
                                       autoShed_Coast$RFOR30))

# Combine to single tibble
CVM_RFOR30 <- rbind(CVM_RFOR30_M, CVM_RFOR30_P, CVM_RFOR30_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_RFOR30) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_RFOR30_C); rm(CVM_RFOR30_M);rm(CVM_P_RFOR30); rm(CVM_RFOR30_P)
```

## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.



## MunMinor Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r watershed Municipal Minor Permits histogram}
# First the human results
ggplot(data = humanShed, aes(x = MunMinor)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = MunMinor)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r Municipal Minor Permits t test}
t.test(humanShed$MunMinor, autoShed$MunMinor)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
#library(CDFt)
```


```{r MunMinor cvm}
CVM_MunMinor <- CramerVonMisesTwoSamples(humanShed$RFOR30,autoShed$RFOR30)
CVM_MunMinor # print result

# Convert U result from cvm to a p value
CVM_P_MunMinor<- 1/6*exp(-CVM_MunMinor)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_MunMinor <- tibble(ID = 'Watershed Percent Forest', 
                     cvm = CVM_MunMinor,
                     pValue = CVM_P_MunMinor)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion MunMinor boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = MunMinor, fill = type)) +
  geom_boxplot()
  
```


And let's also make a scatterplot to show differences

```{r bioregion MunMinor scatterplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = MunMinor, color = type)) +
  geom_point()
```

To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))

# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')
```

First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r MunMinor anova by bioregion}
summary(
  aov(data = allData, 
      MunMinor ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run cvm on each subpopulation. 

```{r MunMinor cvm by bioregion}

CVM_MunMinor_M <- tibble(ID = 'Watershed Municipal Minor Permits Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$MunMinor,
                                       autoShed_Mountain$MunMinor))
CVM_MunMinor_P <- tibble(ID = 'Watershed Municipal Minor Permits Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$MunMinor,
                                       autoShed_Piedmont$MunMinor))
CVM_MunMinor_C <- tibble(ID = 'Watershed Municipal Minor Permits Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$MunMinor,
                                       autoShed_Coast$MunMinor))

# Combine to single tibble
CVM_MunMinor <- rbind(CVM_MunMinor_M, CVM_MunMinor_P, CVM_MunMinor_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_MunMinor) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_MunMinor_C); rm(CVM_MunMinor_M);rm(CVM_P_MunMinor); rm(CVM_MunMinor_P)
```

## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.



## siteRain_mmyr Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r rainfall histogram}
# First the human results
ggplot(data = humanShed, aes(x = siteRain_mmyr)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = siteRain_mmyr)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r siteRain_mmyr t test}
t.test(humanShed$siteRain_mmyr, autoShed$siteRain_mmyr)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
#library(CDFt)
```


```{r siteRain_mmyr cvm}
CVM_siteRain_mmyr <- CramerVonMisesTwoSamples(humanShed$siteRain_mmyr,autoShed$siteRain_mmyr)
CVM_siteRain_mmyr # print result

# Convert U result from cvm to a p value
CVM_P_siteRain_mmyr<- 1/6*exp(-CVM_siteRain_mmyr)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_siteRain_mmyr <- tibble(ID = 'Watershed Rainfall', 
                     cvm = CVM_siteRain_mmyr,
                     pValue = CVM_P_siteRain_mmyr)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion siteRain_mmyr boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = siteRain_mmyr, fill = type)) +
  geom_boxplot()
  
```


And let's also make a scatterplot to show differences

```{r bioregion siteRain_mmyr scatterplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = siteRain_mmyr, color = type)) +
  geom_point()
```

To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))

# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')
```

First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r siteRain_mmyr anova by bioregion}
summary(
  aov(data = allData, 
      siteRain_mmyr ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run cvm on each subpopulation. 

```{r siteRain_mmyr cvm by bioregion}

CVM_siteRain_mmyr_M <- tibble(ID = 'Watershed Percent Forest Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$siteRain_mmyr,
                                       autoShed_Mountain$siteRain_mmyr))
CVM_siteRain_mmyr_P <- tibble(ID = 'Watershed Percent Forest Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$siteRain_mmyr,
                                       autoShed_Piedmont$siteRain_mmyr))
CVM_siteRain_mmyr_C <- tibble(ID = 'Watershed Percent Forest Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$siteRain_mmyr,
                                       autoShed_Coast$siteRain_mmyr))

# Combine to single tibble
CVM_siteRain_mmyr <- rbind(CVM_siteRain_mmyr_M, CVM_siteRain_mmyr_P, CVM_siteRain_mmyr_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_siteRain_mmyr) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_siteRain_mmyr_C); rm(CVM_siteRain_mmyr_M);rm(CVM_P_siteRain_mmyr); rm(CVM_siteRain_mmyr_P)
```

## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.


## ELEVMEAN Analysis

#### Exploratory Data Analysis

It's always good to have an idea of what your data look like before diving into statistical analyses. Here we make a histogram using ggplot2 package to see how our watershed area data fall.

```{r elevation histogram}
# First the human results
ggplot(data = humanShed, aes(x = ELEVMEAN)) +
  geom_histogram()

# Then automated results
ggplot(data = autoShed, aes(x = ELEVMEAN)) +
  geom_histogram()
```

Looks like we are getting the same shape for both datasets- right (positive) skew, non normal (non parametric) data. Exactly what we expected from environmental datasets.

#### Parametric Analysis

Now let's run a students t test on the two datasets to compare their means. A t test is a parametric analysis technique, but we will still use it to get an idea of what our data are telling us.

```{r elevation t test}
t.test(humanShed$ELEVMEAN, autoShed$ELEVMEAN)
```

The t test with an alpha level of 0.05 (default value for t.test() ) indicates the means of the two datasets are not significantly different (p value = 0.8527).


#### Non Parametric Analysis

Now let's try a non parametric analysis, a cramer von mises using the CDFt package.

```{r load cramer library}
#library(CDFt)
```


```{r ELEVMEAN cvm}
CVM_ELEVMEAN <- CramerVonMisesTwoSamples(humanShed$ELEVMEAN,autoShed$ELEVMEAN)
CVM_ELEVMEAN # print result

# Convert U result from cvm to a p value
CVM_P_ELEVMEAN<- 1/6*exp(-CVM_ELEVMEAN)  ###Convert U from cramer von mises to p-value http://hameddaily.blogspot.com/2015/01/goodness-of-fit-test-in-r.html

# and turn result into a tibble (a table-like object) to make it easier to combine result later
CVM_P_ELEVMEAN <- tibble(ID = 'Watershed Elevation', 
                     cvm = CVM_ELEVMEAN,
                     pValue = CVM_P_ELEVMEAN)

```

Given the large p value, it doesn't appear as though there are significant differences between the 


#### Dig in to Bioregional differences

So we really want to compare the differences in subsets of this data, meaning each of the subpopulations of the BioRegion variable. To see what our options are, let's ask R to tell us.

```{r Bioregions human}
unique(humanShed$BioRegion)
```

Can you test to see what the options are for the auto delineated dataset? Hint: they should be the same.

```{r Bioregions auto}
# enter code here

```


let's have a quick look at our dataset using a boxplot now that we know the different bioregions.

```{r bioregion ELEVMEAN boxplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = ELEVMEAN, fill = type)) +
  geom_boxplot()
  
```


And let's also make a scatterplot to show differences

```{r bioregion ELEVMEAN scatterplot}
# combine to single dataset and plot, a bit advanced here but you can replicate
mutate(humanShed, type = 'Human') %>%
  bind_rows(mutate(autoShed, type = 'Automated')) %>%
  ggplot(aes( x = BioRegion, y = ELEVMEAN, color = type)) +
  geom_point()
```

To make further analyses easier, we will subset the full dataset into three separate datasets by bioregion. 

```{r bioregion subsets}
# First smash all the data into a single dataset and mark whether it came from automated or human dataset originally
allData <- mutate(humanShed, type= 'Human') %>%
  bind_rows(mutate(autoShed, type='Auto'))

# then divide these into separate datasets 
humanShed_Mountain <- filter(allData, type == 'Human' & BioRegion == 'Mountain')
humanShed_Piedmont <- filter(allData, type == 'Human' & BioRegion == 'Piedmont')
humanShed_Coast <- filter(allData, type == 'Human' & BioRegion == 'Coast')

autoShed_Mountain <- filter(allData, type == 'Auto' & BioRegion == 'Mountain')
autoShed_Piedmont <- filter(allData, type == 'Auto' & BioRegion == 'Piedmont')
autoShed_Coast <- filter(allData, type == 'Auto' & BioRegion == 'Coast')
```

First let's do a parametric test on the bioregional differences. Instead of doing multiple t tests, it's best to do what is called an anova because it improves your statistical power for testing multiple categorical variables in a dataset. We are going to do a two way anova because we are testing human vs automated results (1) by (*) Mountain vs Piedmont vs Coast (1) = 2 way anova.


```{r ELEVMEAN anova by bioregion}
summary(
  aov(data = allData, 
      ELEVMEAN ~ type * BioRegion))

```

Area ANOVA Interpretation: The BioRegion is the only significant p value (0.000829 is way less than 0.05, note the *** shows that it is significant at the 0.001 level). But that doesn't tell us much about our methods bc it's only comparing if the area is different between Mountain/Piedmont/Coast. The type (Human vs Auto) is not significant, nor is the interaction of type and BioRegion (meaning the relationship between the area and bioregion tested is not dependent on delineation method). 


Now we will run cvm on each subpopulation. 

```{r ELEVMEAN cvm by bioregion}

CVM_ELEVMEAN_M <- tibble(ID = 'Watershed Elevation Mountain',
                     cvm = CramerVonMisesTwoSamples(humanShed_Mountain$ELEVMEAN,
                                       autoShed_Mountain$ELEVMEAN))
CVM_ELEVMEAN_P <- tibble(ID = 'Watershed Elevation Piedmont',
                     cvm = CramerVonMisesTwoSamples(humanShed_Piedmont$ELEVMEAN,
                                       autoShed_Piedmont$ELEVMEAN))
CVM_ELEVMEAN_C <- tibble(ID = 'Watershed Elevation Coast',
                     cvm = CramerVonMisesTwoSamples(humanShed_Coast$ELEVMEAN,
                                       autoShed_Coast$ELEVMEAN))

# Combine to single tibble
CVM_ELEVMEAN <- rbind(CVM_ELEVMEAN_M, CVM_ELEVMEAN_P, CVM_ELEVMEAN_C) %>%
  # Convert U result from cvm to a p value, all at once
  mutate(pValue = 1/6*exp(-cvm)) %>% # Convert U from cramer von mises to p-value
  # Combine with result from full dataset
  bind_rows(CVM_P_ELEVMEAN) %>%
  arrange(ID) # reorder alphabetically 

# Clean up workspace to get rid of all the extra objects made in the process
rm(CVM_ELEVMEAN_C); rm(CVM_ELEVMEAN_M);rm(CVM_P_ELEVMEAN); rm(CVM_ELEVMEAN_P)
```

## Rinse and repeat

now you are going to do the same analyses for each of the parameters of interest statewide and then break it down by bioregion. All you need to do is copy the code from above and replace the area variable with each of the parameters of interest.

## Save Results

When you are finished, you can combine your results into a single object and save your results to a csv file like so:

```{r save results}
# Combine results
allResults <- rbind(CVM_Area, CVM_PFOR, CVM_PWETL, CVM_RFOR30, 
                    CVM_MunMinor, CVM_siteRain_mmyr, CVM_ELEVMEAN)
# save results
write.csv(allResults, 'data/Results/CVM_results.csv', row.names = FALSE)

```




## Maps

Now we are going to update the maps for your poster with R instead of using Esri's ArcGIS software (proprietary). These maps will be exported to a .png for easy inclusion in your poster-building software. We are going to use the sf package in R to use spatial data objects for plotting and then use the ggplot2 package (loaded with tidyverse package) for the actual plots.

```{r bring in spatial library}
library(sf)
```

First, we need spatial data in order to make maps. But notice in the glimpse() above that there is no actual spatial information for us to plot in the results (no latitude/longitude information or shapes for the polygons). We will need to bring in the raw spatial data you all processed in order to make maps. 

```{r bring in spatial data}
wshdPolys <- st_read('GISdata/TwinWatersheds_prj.shp') %>% # watersheds that were created using automated delineation technique
  st_transform(4326) #reproject to WGS84 for mapping
wshdSites <- st_read('GISdata/TwinSites_prj.shp') %>% # points
    st_transform(4326) #reproject to WGS84 for mapping
```

And we will bring in a few base layers to make the maps a bit more understandable: a Virginia state outline and US EPA Level III Ecoregions. 

```{r bring in baselayers}
VAoutline <- st_read('GISdata/mapData/Va_otlne.shp')
VAecoregions <- st_read('GISdata/mapData/VA_level3ecoregion.shp')
```

The ecoregions brought in don't quite match the way we analyzed our dataset above (Mountain, Piedmont, Coast). Have a look at what came in:

```{r ecoregion options}
unique(VAecoregions$US_L3NAME)
```

We will need to simplify this layer to match our previous analysis. We will do that by combining the ecoregions by this format: 
Combined level III EcoRegions - 69, 67, 66 = Mountain 
                                 64,45 = Piedmont 
                                 65,63 = coastal plain
                                 
Here is all the code to do so, don't worry about understanding it all.

```{r combine ecoregions to bioregions for plotting}
VAbioregions <- mutate(VAecoregions, 
                       Bioregion = as.factor(case_when(US_L3CODE %in% c(66, 67, 69) ~ 'Mountain',
                                             US_L3CODE %in% c(45, 64) ~ 'Piedmont',
                                             US_L3CODE %in% c(63, 65) ~ 'Coast'))) %>%
  group_by(Bioregion) %>% # group by new variable
  summarise() # make into unified geometries
```


Last check, before we can plot things on the same map, we need to make sure their coordinate reference system (CRS) and projections are the same. These refer to how the data are represented on a 2D space and basically makes sure things will look like we expect them to look. 

```{r crs check}
# test if everyone has same crs, first the long way
st_crs(wshdPolys) == st_crs(wshdSites)
st_crs(wshdPolys) == st_crs(VAbioregions)
st_crs(wshdPolys) == st_crs(VAoutline)
st_crs(wshdSites) == st_crs(VAbioregions)
st_crs(wshdSites) == st_crs(VAoutline)
st_crs(VAbioregions) == st_crs(VAoutline)
# a bit complicated to make sure you are really testing every possible combination

# test if everyone has same crs, now the short way, this is called a function
all(sapply(list(st_crs(wshdPolys), st_crs(wshdSites), st_crs(VAbioregions), st_crs(VAoutline)),
           function(x) x == st_crs(wshdPolys)))
```


First let's plot where our polygons fall out across the state (we want to demonstrate how they are not clustered in on area within state).

```{r VA map and polgons}
ggplot(data = VAoutline) +
  geom_sf() +
  geom_sf(data = wshdPolys)
```

Now a map to demonstrate the spread of sites across bioregions.

```{r Bioregion map and points}
ggplot(data = VAbioregions) +
  geom_sf() +
  geom_sf(data = wshdSites)
```


And now let's make these into publishable maps (make them pretty). 

```{r pretty watershed map}
library(ggthemes)

watershedPlot <- ggplot(data = VAoutline) +
  geom_sf() +
  geom_sf(data = wshdPolys, fill="white") + 
  ggthemes::theme_map()
watershedPlot
```


```{r}
bioregionPlot <- ggplot(data = VAbioregions) +
  geom_sf(aes(fill = Bioregion)) +
  geom_sf(data = wshdSites) + 
  theme_void()
bioregionPlot
```


```{r}
ggsave("watershedPlot.png", plot = watershedPlot, width = 6, height = 6, dpi = "screen")
ggsave("bioregionPlot.png", plot = bioregionPlot, width = 6, height = 6, dpi = "screen")

```


### Map showing difference between human and automated delineations

Now we want a zoomed map of a single watershed to demonstrate what the differences in the two methods actually look like. I cherry picked the inputs and because the differences in area are highest in the mountains (see boxplots) I chose one of those sites.

```{r}
library(raster)

# bring in NLCD 2016
landcover <- raster("GISdata/mapData/nlcd2016.TIF")


# human watersheds in mountains
humanShed_Poly <- st_read('GISData/mapData/AllWatersheds_through2016.shp') %>%
  filter(StationID %in% humanShed_Mountain$StationID) %>% 
  arrange(StationID)
humanShed_Point <- st_read('GISData/TwinSites_prj.shp') %>%
  filter(StationID %in% humanShed_Mountain$StationID) %>% 
  arrange(StationID)


# automated watersheds in mountains
autoShed_Poly <- filter(wshdPolys, StationID %in% humanShed_Poly$StationID) %>%
  st_transform(st_crs(landcover)) %>%
  arrange(StationID)





i = 21 # potential sites to show 1, 5, 9, 10



humanShed_Poly[i,]$StationID
autoShed_Poly[i,]$StationID
humanShed_Point[i+2,]$StationID


z <- crop(landcover,humanShed_Poly[i,], small=T, na.rm=F)

# save this as a jpeg in your working directory
#jpeg('singleWatershed.jpg', width = 600, height = 600)
plot(z)
plot(humanShed_Poly[i,], col = NA, border = 'red', add = T)
plot(autoShed_Poly[i,], col = NA, border = 'black', add = T)
legend('topleft',legend=c('Human Watershed', 'Automated Watershed'),
       title='Legend',bty='n',inset=0.15,pch=c(15,15,19),
       cex=0.8, col=c('red','black'))
#jpeg('singleWatershed1.jpg', width = 350, height = 350)
#dev.off()



```


```{r}

stationIwant <- '6CSTU000.15'#'7-XDM000.50'#'5AXGI001.79'#,,)c('6ADIS022.34')#,

landcover <- raster("GISdata/mapData/nlcd2016.TIF")
#landcover <- raster("GISdata/mapData/vaelevation.TIF")
  

# human watersheds in mountains
humanShed_Poly <- st_read('GISData/mapData/AllWatersheds_through2016.shp') %>%
  #filter(StationID %in% humanShed_Mountain$StationID) %>% 
  arrange(StationID) %>%
  filter(StationID == stationIwant)
humanShed_Point <- st_read('GISData/TwinSites_prj.shp') %>%
  #filter(StationID %in% humanShed_Mountain$StationID) %>% 
  arrange(StationID)%>%
  filter(StationID == stationIwant)


# automated watersheds in mountains
autoShed_Poly <- filter(wshdPolys, StationID %in% humanShed_Poly$StationID) %>%
  st_transform(st_crs(landcover)) %>%
  arrange(StationID)%>%
  filter(StationID == stationIwant)

#GIVEN lat/long
probData_sf <- read_csv('data/Wadeable_ProbMon_2001-2016_EVJ.csv') %>%
  st_as_sf(coords = c("LongitudeDD", "LatitudeDD"),  # make spatial layer using these columns
           remove = F, # don't remove these lat/lon columns from the dataset (may want to use them later)
           crs = 4326) %>%
  st_transform(st_crs(autoShed_Poly)) %>%
  filter(StationID == stationIwant)


z <- crop(landcover,humanShed_Poly, small=T, na.rm=F)

# save this as a jpeg in your working directory
jpeg(paste0(stationIwant,'.jpg'), width = 600, height = 600)
plot(z)
plot(humanShed_Poly, col = NA, border = 'red', add = T)
plot(autoShed_Poly, col = NA, border = 'black', add = T)
plot(humanShed_Point, col = 'blue',add = T)
plot(probData_sf, col= 'yellow', add= T)
legend('topleft',legend=c('Human Watershed', 'Automated Watershed'),
       title='Legend',bty='n',inset=0.15,pch=c(15,15,19),
       cex=0.8, col=c('red','black'))

```

